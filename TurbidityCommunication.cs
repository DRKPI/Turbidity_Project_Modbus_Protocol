using System;
using System.IO.Ports;
using System.Threading;
using System.IO;

namespace Turbidity
{
    class TurbidityCommunication
    {
        const bool DEBUG = true;
        private static SerialPort sp = null;
        private string testReceiveMsg = "04 03 04 EF 61 3C F7 DB E9 00";
        public string turbidNum = "";
        public byte[] buffRec { get; private set; }
        public byte[] message { get; private set; } = new byte[8];
        public string sendMsg { get; private set; }
        public string receiveMsg { get; private set; }
        public string errorMessage { get; set; } = String.Empty;
        public string secondaryErrorMsg { get; private set; } = String.Empty;
        public int timeInterval { get; private set; } = 1;
        public string onlineFilePath { get; set; } = String.Empty;


        //Constructor - autogenerated on compile

        /// <summary>
        /// Build the byte[] for modbus communication/request of Turbidity data
        /// Asks for data in register 40001 (0000) with read code 03
        /// </summary>
        /// <returns>modbus package</returns>
        public void BuildMessage()
        {
            if (!DEBUG)
            {
                byte slaveID = 04;// Slave ID - this can be found on the controller menu under Network
                byte functionCode = 03;// Function code - 03 is for reading coils/registers
                ushort startAddress = 0000;// Starting Address - register 40001 holds the turbidity reading as a float
                ushort numberOfRegisters = 0002;// Quantity of Registers to read - only need reg 40001

                // Build Message(FC03)
                message[0] = slaveID;// Slave ID
                message[1] = functionCode;// Function
                message[2] = (byte)(startAddress >> 8);// Starting Address High
                message[3] = (byte)startAddress;// Starting Address Low
                message[4] = (byte)(numberOfRegisters >> 8);// quantity of Registers High
                message[5] = (byte)numberOfRegisters;// quantity of Registers Low
                //add checkSum to byte[]
                byte[] checkSum = CRC16(message);
                message[6] = checkSum[0];// error check Low
                message[7] = checkSum[1];// error check High 
            }
        }// end Function BuildMessage

        /// <summary>
        /// CRC16 checksum
        /// </summary>
        /// <param name="data">byte[]</param>
        /// <returns>checkSum byte[] to add to modbus package</returns>
        /// This checksum algorithm was taken from an online tutorial (https://stackoverflow.com/questions/51286751/c-sharp-generating-a-crc8-byte-method-with-a-byte-array-input)
        /// The code has been altered to work with my program
        private static byte[] CRC16(byte[] data)
        {
            byte[] checkSum = new byte[2];
            ushort reg_crc = 0Xffff;

            if (!DEBUG)
            {
                for (int i = 0; i < data.Length - 2; i++)
                {
                    reg_crc ^= data[i];
                    for (int j = 0; j < 8; j++)
                    {
                        if ((reg_crc & 0x01) == 1)
                        {
                            reg_crc = (ushort)((reg_crc >> 1) ^ 0xA001);
                        }
                        else
                        {
                            reg_crc = (ushort)(reg_crc >> 1);
                        }
                    }
                }
                checkSum[1] = (byte)((reg_crc >> 8) & 0xFF);
                checkSum[0] = (byte)(reg_crc & 0xFF);
            }
            return checkSum;
        }// end Function checkSum

        /// <summary>
        /// Reads in config file info and
        /// Opens a serial port connection
        /// </summary>
        /// <param name="errorMessage">an errorMessage</param>
        public void OpenSerialPort()
        {
            //Create a default config file
            Turbidity_Project_Modbus_Protocol.Config.CreateConfigFile();
            //Read port, baud rate, and time interval from config file
            Turbidity_Project_Modbus_Protocol.Config.ReadFromConfigFile();

            //Put data from configData into variables
            string port = Turbidity_Project_Modbus_Protocol.Config.configData[0];
            int baudRate = 0;
            try
            {
                if (!int.TryParse(Turbidity_Project_Modbus_Protocol.Config.configData[1], out baudRate))
                {
                    errorMessage = String.Empty;
                    //if could not parse let user know
                    LogError(errorMessage = "Choose a valid Baud Rate from the \"Edit Settings\" page.\n And it must match the sc200 controllers Baud Rate." + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                LogError(errorMessage = ex.Message.ToString());
            }
            //Set timeInterval if serial port is not already open
            if (sp == null)
            {
                try
                {
                    if (!int.TryParse(Turbidity_Project_Modbus_Protocol.Config.configData[2], out int interval))
                    {
                        errorMessage = String.Empty;
                        //if could not parse let user know
                        LogError(errorMessage = "Time interval must be a whole number written in minutes (ie. 1hr = 60)" + Environment.NewLine);
                    }
                    timeInterval = interval;
                }
                catch (Exception ex)
                {
                    errorMessage = String.Empty;
                    LogError(errorMessage = ex.Message.ToString());
                }
            }

            //TODO Read File Path from config file


            //Open the Serial Port using settings obtained from the config file
            if (!DEBUG)
            {
                int attempt = 1;
                while (attempt < 4)
                {
                    try
                    {
                        if (sp != null && sp.IsOpen)
                        {
                            sp.Close();
                            sp.Dispose();
                        }
                        sp = new SerialPort(port, baudRate, Parity.None, 8, StopBits.One);
                        sp.Open();
                        return;
                    }
                    catch (Exception ex)
                    {
                        errorMessage = String.Empty;
                        //Send error messgage to the form load method in FormMain.cs
                        LogError(errorMessage = ex.Message.ToString());
                        Thread.Sleep(TimeSpan.FromSeconds(.5));
                        attempt++;
                        // close serial port
                        sp.Close();
                        sp.Dispose();
                    } 
                }
            }
        }// end Function OpenSerialPort
        
        /// <summary>
        /// Send package over the serial port
        /// </summary>
        /// <param name="frame"></param>
        public void WriteToSP(byte[] frame)
        {
            if (!DEBUG)
            {
                try
                {
                    sp.Write(frame, 0, frame.Length);// send frame
                }
                catch (Exception ex)
                {
                    errorMessage = String.Empty;
                    //Send error messgage to the form load method in FormMain.cs
                    LogError(errorMessage = ex.ToString());

                    if (sp.IsOpen)
                    {
                        sp.Close();
                        //write out message that sending message to sensor failed
                        secondaryErrorMsg = "Could not send request, please retry.";
                    }
                }
            }
        }// end Function WriteToSP

        /// <summary>
        /// Read package received over serial port and 
        /// call ConvertByteDataToString
        /// </summary>
        /// <param name="errorMessage"></param>
        public void ReadFromSP()
        {
            if (!DEBUG)
            {
                try
                {
                    buffRec = new byte[sp.BytesToRead];
                    sp.Read(buffRec, 0, buffRec.Length);
                }
                catch (Exception ex)
                {
                    errorMessage = String.Empty;
                    //Log any error message
                    LogError(errorMessage = ex.ToString());

                    // close serial port
                    sp.Close();
                }
                ConvertByteDataToString(buffRec);
            }
            else
            {
                ConvertByteDataToString(buffRec);
            }
        }// end Function ReadFromSP

        /// <summary>
        /// Puts byte data received into a string variable then
        /// calls ConvertDataToFloat function
        /// </summary>
        /// <param name="frame"></param>
        /// <param name="buffRec"></param>
        public void ConvertByteDataToString(byte[] buffRec)
        {
            receiveMsg = string.Empty;

            if (!DEBUG)
            {
                //Received data saved to string
                foreach (var item in buffRec)
                {
                    receiveMsg += string.Format("{0:X2} ", item);//Saves received bytes as hex values, found these easier to work with
                }
            }
            else
            {
                receiveMsg = testReceiveMsg;
            }
            ConvertDataToFloat(receiveMsg);
        }// end Function ConvertByteDataToString

        /// <summary>
        /// Trims off unneeded elements from receivedMsg, reorders endianness and 
        /// converts to a float value. Then converts float value to string to write
        /// out to a file
        /// </summary>
        /// <param name="receivedMsg"></param>
        private void ConvertDataToFloat(string receivedMsg)
        {
            // Split on white space to put in array
            string[] convertData = receivedMsg.Split();
            string[] tempData1 = new string[4];
            string[] tempData2 = new string[4];
            int j = 0;
            //Put the trimmed data into array element
            for (int i = 3; i < convertData.Length - 3; i++)
            {
                tempData1[j] = convertData[i];
                j++;
            }

            //Reorder the array element to match endianness (little endian/mid little endian)
            tempData2[0] = tempData1[2];
            tempData2[1] = tempData1[3];
            tempData2[2] = tempData1[0];
            tempData2[3] = tempData1[1];

            //Convert data to a float
            string reorderdHex = string.Concat(tempData2);// put hex values back into a string
            try
            {
                uint num = uint.Parse(reorderdHex, System.Globalization.NumberStyles.AllowHexSpecifier);
                byte[] floatVals = BitConverter.GetBytes(num);
                float f = BitConverter.ToSingle(floatVals, 0);
                turbidNum = f.ToString("N4");//Convert float value to string and rounded to 4 decimal places
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                LogError(errorMessage = ex.Message.ToString());
            }
        }// end Function ConvertDataToFloat

        /// <summary>
        /// Writes the Turbidity number received from the sc200 Controller out to a text file
        /// This is an appended file with the date and time stamp attached to each value
        /// </summary>
        public void WriteTurbidDataToFile()
        {
            string dateTimeStamp = DateTime.Now.ToString("MM/dd/yyyy HH:mm");
            string year = DateTime.Parse(DateTime.Now.ToString()).Year.ToString();
            string localStoragePath = Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, year + "_Turbidity_Readings.txt");
            //TODO: allow user to choose path for storing online
            onlineFilePath = Turbidity_Project_Modbus_Protocol.Config.configData[3];
            string onlineStoragePath = onlineFilePath + "\\" + year + "_Turbidity_Readings.txt";

            //Save locally
            //Check if file exist, if not then create file with header information
            //File name will have the current year as part of file name
            //Compare current year (of file name) to current year, if not a match create new file for new year
            try
            {
                //If config.txt does not exist create with the following information
                if (!File.Exists(localStoragePath))
                {
                    //Create default text to write to file
                    string defaultTurbidReadingFile = "Turbidity Numbers Received from Controller"
                    + Environment.NewLine + "-------------------------------------"
                    + Environment.NewLine + "Date\t\t\t" + "Turbidity Reading"
                    + Environment.NewLine;
                    //Write to file
                    using (StreamWriter file = new StreamWriter(localStoragePath))
                    {
                        file.Write(defaultTurbidReadingFile);
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }

            //Append turbidNum and date and time to existing file
            try
            {
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file = new StreamWriter(localStoragePath, true))
                {
                    file.WriteLine(dateTimeStamp + "\t" + turbidNum + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                //Send error messgage to the form load method in FormMain.cs
                LogError(errorMessage = Environment.NewLine + ex.ToString());
            }

            //Save to cloud storage
            //Check if file exist, if not then create file with header information
            //File name will have the current year as part of file name
            //Compare current year (of file name) to current year, if not a match create new file for new year
            try
            {
                //If config.txt does not exist create with the following information
                if (!File.Exists(onlineStoragePath))
                {
                    //Create default text to write to file
                    string defaultTurbidReadingFile = "Turbidity Numbers Received from Controller"
                    + Environment.NewLine + "-------------------------------------"
                    + Environment.NewLine + "Date\t\t\t" + "Turbidity Reading"
                    + Environment.NewLine;
                    //Write to file
                    using (StreamWriter file = new StreamWriter(onlineStoragePath))
                    {
                        file.Write(defaultTurbidReadingFile);
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }

            ////Append turbidNum and date and time to existing file
            try
            {
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file = new StreamWriter(onlineStoragePath, true))
                {
                    file.WriteLine(dateTimeStamp + "\t" + turbidNum + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                //Send error messgage to the form load method in FormMain.cs
                LogError(errorMessage = Environment.NewLine + ex.ToString());
            }
        }// end Function WriteTurbidDataToFile

        /// <summary>
        /// Log error message out to file
        /// </summary>
        /// <param name="errorMessage"></param>
        public void LogError(string errorMessage)
        {
            string dateTimeStamp = DateTime.Now.ToString();
            string path = Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "log.txt");

            try
            {
                // Append new text to an existing file.
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file = new StreamWriter(path, true))
                {
                    file.WriteLine(dateTimeStamp + Environment.NewLine + errorMessage + Environment.NewLine + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                secondaryErrorMsg = String.Empty;
                //The following conditions may cause an exception:
                //The file exists and is read - only
                //The disk may be full
                secondaryErrorMsg = ex.Message;
            }
        }// end Function LogError
    }// end Class
}// end Namespace